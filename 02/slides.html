<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Veljko Petrović">
  <title>Tehnologija</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4//dist/theme/night.css" id="theme">
  <link rel="stylesheet" href="slides.css"/>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Tehnologija</h1>
  <p class="author">Veljko Petrović</p>
  <p class="date">Oktobar, 2022</p>
</section>

<section>
<section id="tehnologije-računarstva-u-oblaku" class="title-slide slide level1">
<h1>Tehnologije računarstva u oblaku</h1>
<p>Hardversko/softverska pozadina</p>
</section>
<section id="svrha-predavanja" class="slide level2">
<h2>Svrha predavanja</h2>
<ul>
<li>Ovo predavanja pokušava da prođe kroz osnove tehnologija koje čine računarstvo u oblaku mogućim</li>
<li>Glavne tehnologije koje nas zanimaju su
<ul>
<li>Mrežne tehnologije visokog kapaciteta</li>
<li>Tehnologije računarskih postrojenja</li>
<li>Virtualizacija</li>
<li>Web tehnologija</li>
<li>Tehnologija višestruke upotrebe</li>
<li>Tehnologija servisnih arhitektura</li>
</ul></li>
</ul>
</section>
<section id="šta-nije-svrha-predavanja" class="slide level2">
<h2>Šta nije svrha predavanja</h2>
<ul>
<li>Nije svrha ovoga da se sve ove tehnologije u potpunosti nauče i razumeju ovde</li>
<li>Prvo, nema vremena.</li>
<li>Drugo, trebalo bi da dosta ovoga znate, barem na nekakvom nivou.</li>
<li>Umesto toga, ovo nabrajanje, koje je nužno na visokom nivou i vrlo komprimovano služi da bi razumeli kako se sve ovo povezuje i kako čini računarstvo u oblaku i <em>mogućim</em> ali i ograničenim.</li>
</ul>
</section>
<section id="ograničenost-i-mogućnost" class="slide level2">
<h2>Ograničenost i mogućnost</h2>
<ul>
<li>Generalno bilo koja tehnologija koja omogućava nekakvu pod-oblast računarskih nauka, je takođe i glavna međa koja <em>ograničava</em> tu pod-oblast.</li>
<li>Asinhrona priroda komunikacija u modernoj Web aplikaciji povezana sa DOM stablom kao univerzalnim jezikom prikaza (sa svim svojim ograničenjima) je glavni razlog zašto razvoj interfejsa izgleda kako izgleda i ima prioritete koje ima.</li>
<li>Da su se svi browser alati dogovorili da imaju brz način piksel-savršene kontrole prikaza na vreme, na primer, situacija bi bila znatno drugačija.</li>
</ul>
</section></section>
<section>
<section id="mrežne-tehnologije-visokog-kapaciteta" class="title-slide slide level1">
<h1>Mrežne tehnologije visokog kapaciteta</h1>
<p>Kako se podaci kreću?</p>
</section>
<section id="oblak-zavisi-od-interneta" class="slide level2">
<h2>“Oblak” zavisi od Interneta</h2>
<ul>
<li>Računarstvo u oblaku nikada ne bi uspelo da nije internet komunikacija</li>
<li>Sa jedne strane Internet je vitalan da bi mogli da imamo dovoljno korisnika da nam uopšte <em>treba</em> CC</li>
<li>Sa druge, samo Internet omogućava mrežnu fleksibilnost da koristimo računarske resurse distribuirane preko celog sveta</li>
<li>Naravno, dovoljno velika firma bi mogla da ima potpuno lokalni oblak čiji su korisnici unutar firme i gde su sve veze preko LAN tehnologije.</li>
</ul>
</section>
<section id="cc-bez-interneta" class="slide level2">
<h2>CC bez Interneta</h2>
<ul>
<li>Kasnije kada budemo diskutovali arhitektonske šablone CC instalacija biće više reči o ovom pod-tipu</li>
<li>Dovoljno je reći da
<ul>
<li>Nije dominantan: većina upotrebe CC je preko Interneta i to sa dobrim razlogom.</li>
<li>Organizacija dovoljno velikog LANa će biti veoma slična onoj koja se koristi za Internet, barem danas.</li>
</ul></li>
</ul>
</section>
<section id="hijerarhija-isp" class="slide level2">
<h2>Hijerarhija ISP</h2>
<ul>
<li>Internet nema gotovo nikakvo centralizovano upravljajuće telo izuzimajući ICANN (mada je čak i on onoliko koliko može biti distribuiran)</li>
<li>Uprkos tome, Internet nije, baš, decentralizovan koliko je distribuiran</li>
<li>On postoji kao kontinuirano povezivanje ogromnih mreža koje opslužuju (kao unificirajući entiteti)  Internet Service Provider  institucije prvog ranga</li>
</ul>
</section>
<section id="hijerarhija-isp-1" class="slide level2">
<h2>Hijerarhija ISP</h2>
<ul>
<li>Te ogromne mreže (često nacionalne ili čak trans-nacionalne) se sastoje uglavnom od velikih spojenih mreža</li>
<li>Te velike mreže, često regionalnog karaktera, koje se spajaju su mreže koje stvaraju ISP drugog ranga</li>
<li>A regionalne mreže se, pak, sastoje uglavnom od srednjih spojenih mreža: to su mreže ISP trećeg ranga i, iako su male u odnosu na mreže čiji konstituent čine, i dalje su velike.</li>
<li>Bilo koji rang ISP može imati i obične, individualne klijente ili spajati mreže.</li>
</ul>
</section>
<section id="hijerarhija-isp-2" class="slide level2">
<h2>Hijerarhija ISP</h2>
<ul>
<li>Dok ste na FTN-u vi ste korisnici Akademske Računarske Mreže Univerziteta u Novom Sadu (ARMUNS) koja je za vas ISP</li>
<li>Ceo ARMUNS se spaja sa ARMU-ovima drugih univerziteta u Srbiji da tvori akademsku mrežu cele Srbije, koja funkcioniše kao ISP za univerzitete i spaja njihove mreže.</li>
<li>Dalje, ta akademska mreža Srbije je (verovatno) objedinjena sa drugim mrežama istog tipa u okviru nekakve objedinjene mreže Evrope, koja funkcioniše kao ISP za tu mrežu.</li>
<li>Ova arhitektura je ugrubo</li>
</ul>
</section>
<section id="zašto-nas-ovo-zanima" class="slide level2">
<h2>Zašto nas ovo zanima?</h2>
<ul>
<li>Ovakva arhitektura Interneta pokazuje da postoji zanimljiva <em>lokalnost</em> u mrežama.</li>
<li>Razdaljine nisu nužno geografski određene (mada tiranija brzine svetlosti i dalje opstaje) nego zavise u velikoj meri od broja skokova između uređaja neophodnih da se ode od jednog do drugog dela mreže.</li>
<li>To znači da se određenim entitetima isplati da imaju direktno naloge kod provajdera prvog ranga</li>
<li>Primer: Netflix</li>
</ul>
</section>
<section id="priroda-internet-komunikacije" class="slide level2">
<h2>Priroda Internet komunikacije</h2>
<ul>
<li>Internet komunikacija ne ide uvek istim putanjama</li>
<li>Ako želimo da komuniciramo, recimo, sa drugim ARMUNS računarom šanse su ogromne da nikad nećemo napustiti ARMUNS mrežu i <em>najverovatnija</em> putanja je uz nivoe hijerarhije i onda horizontalno, to nije neophodno ili sigurno</li>
<li>Sistem je konfigurisan tako da podaci mogu da idu bilo kojom putanjom od čvora do čvora dok ne stignu do svog odredišta, potencijalno istovremeno iz mnogo strana</li>
<li>To znači da ako se neki link optereti ili prekine, mreža se ‘samoizleči’ i nađe se alternativna putanja</li>
</ul>
</section>
<section id="kako-je-ovo-moguće" class="slide level2">
<h2>Kako je ovo moguće?</h2>
<ul>
<li>Postoje dve fundamentalne tehnologije koje omogućavaju ovo ponašanje:
<ul>
<li>Datagramski paketni mrežni protokoli</li>
<li>Dinamičko rutiranje</li>
</ul></li>
</ul>
</section>
<section id="datagramski-paketni-mrežni-protokoli" class="slide level2">
<h2>Datagramski paketni mrežni protokoli</h2>
<ul>
<li>Svi podaci u ovakvoj mreži se pakuju u pakete sa maksimalnom dužinom i svim metapodacima neophodnim da podaci unutar paketa stignu na pravo odredište</li>
<li>Paketi su numerisani i može se identifikovati pravi redosled paketa ako neki izostane ili stigne na odredište u pogrešnom redosledu</li>
<li>Paketi su adresirani sa jedinstvenim identifikatorom odredišta
<ul>
<li>Na IP mrežama to je IP adresa koja je ili 32 ili 128 bita u zavisnosti da li govorimo o IPv4 ili $IPv6% adresama</li>
<li>Na nižem nivou, unutar mreža Ethernet tipa to je MAC odnosno  Media Access Control  adresa koja je 48-bita i određena na nivou fizičkog uređaja.</li>
<li>Kada podatak stigne na računar, softver odgovoran da obrađuje podatke se bira na osnovu <em>porta.</em> proste 16-bitne numeričke vrednosti koja se tipično označava kao broj od 1 do 65535</li>
</ul></li>
</ul>
</section>
<section id="slojevi" class="slide level2">
<h2>Slojevi?</h2>
<ul>
<li>OSI mrežni model priznaje sedam slojeva
<ul>
<li>Fizički - Vodi računa o tome kako variranjem fizičkih veličina da se prenose binarni podaci (osmožilni kabl)</li>
<li>Logičko-vezni - Vodi računa o tome kako da se tok bita prenese od jednog do drugog uređaja koji dele fizički medijum, jedinica transporta je <em>frejm</em> (Ethernet)</li>
<li>Mrežni - Vodi računa o komunikaciji između različitih fizičkih medija, jedinica transporta je <em>paket</em> (IP)</li>
<li>Transportni - Vodi računa o tome da svi podaci iz jednog pokušaja slanja odista stignu na drugu stranu i podpadnu pod kontrolu aplikacije koja je odgovorna za njih, jedinica transporta je <em>segment</em> (TCP)</li>
<li>Sesijski - Vodi računa o tome da se zna koje komunikacije pripadaju kojoj sesiji i da se prati stanje konekcije, autorizacije i identiteta  (HTTP  ali vidi kasnije)</li>
<li>Prezentacioni - Vodi računa o formatiranju podataka koji se šalju  (JSON/utf8) </li>
<li>Aplikativni - Radi nešto korisno sa podacima  (REST  applikacija)</li>
</ul></li>
</ul>
</section>
<section id="slojevi-1" class="slide level2">
<h2>Slojevi?</h2>
<ul>
<li>U praksi se koristi model koji proističe iz  TCP/IP  protokol seta i koji ima <em>pet</em> slojeva zato što su sesijski, prezentacioni, i aplikatinvi sloj kombinovani u samo jedan, aplikativni sloj.</li>
<li>Zbog toga je ono sortiranje na prošlom slajdu imalo ‘vidi kasnije’ u sebi.</li>
<li>U praksi odgovornosti zadnjih tri sloja su kombinovane</li>
</ul>
</section>
<section id="kombinacija-slojeva" class="slide level2">
<h2>Kombinacija slojeva</h2>
<ul>
<li>Ono što čini ovaj model moćnim jeste sposobnost slaganja mrežnih slojeva tako da Ethernet frejm sadrži IP paket koji sadrži TCP segment koji sadrži…</li>
<li>Budući da svaki nivo ne zna šta znače bitovi koje prenosi (tj. IP ne zna da li su bitovi koje prenosi TCP ili UDP ili nešto sasvim novo), ovaj sistem može lako da se menja.</li>
<li>Najintuitivnije je kako se isti  TCP/IP  stek prenosi i kroz bežične i žičane mreže</li>
</ul>
</section>
<section id="tuneliranje" class="slide level2">
<h2>Tuneliranje</h2>
<ul>
<li>To štu su sadržaji jedinica transporta proizvoljni setovi bajtova omogućava trik poznat kao <em>tuneliranje</em></li>
<li>Ideja je da se u protokol višeg nivoa kao sadržaj umetnu podaci koji pripadaju nižem protokolu</li>
<li>Onda se na stani primaoca softver konfiguriše tako da ekstrahuje te podatke i tretira ih kao da opisuju taj niži protokol</li>
<li>Ovo je neverovano moćna tehnologija koja čini koncept VPN tehnologije mogućim</li>
</ul>
</section>
<section id="tuneliranje-1" class="slide level2">
<h2>Tuneliranje</h2>
<ul>
<li>Klasičan primer tuneliranja jeste upotreba SSH protokola (koji pripada aplikativnom sloju) da u svom sadržaju (gde normalno idu komande za udaljenu kontrolu računara) šalje pakete i segmente klasične  TCP/IP  veze</li>
<li>Time je moguće da pristupate lokalnim mrežnim resursima udaljeng računara kroz mrežu na bezbedan način, budući da morate uspostaviti autorizovan enkriptovan kanal pre bilo kakve komunikacije.</li>
<li>Ovakvi tuneli se mogu uspostaviti i protokolima namenjenim za baš ovo, ako je takva veza dugotrajna onda se ovo još i zovu virtualizovane privatne mreže, budući da se preko tog šifrovanog kanala formira veza koja omogućuje da se dve lokalne mreže objedine u jednu.</li>
</ul>
</section>
<section id="dinamičko-rutiranje" class="slide level2">
<h2>Dinamičko rutiranje</h2>
<ul>
<li>Ruter je mrežni uređaj (interno običan računar) koji ima više mrežnih interfejsa koji su deo različitih mreža</li>
<li>Funkcija rutera je da više mreža objedini u jednu tako što usmerava (rutira) komunikaciju između tih mreža</li>
<li>Ruter ne može da zna topologiju kompleksnog sistema u koji je uključen, nužno, ali mora da zna koje linkove ima i da ima nekakvo pravilo koje šalje pakete u jednom smeru ili drugom</li>
<li>To ‘pravilo’ se tipično zove <em>tabela rutiranja</em></li>
</ul>
</section>
<section id="dinamičko-rutiranje-1" class="slide level2">
<h2>Dinamičko rutiranje</h2>
<ul>
<li>Neki uređaji imaju lak posao</li>
<li>Vaš kućni ruter mora da pamti samo dva pravila
<ul>
<li>Ako adresa počinje sa, na primer, <code>192.168.1</code> i ima kao zadnji bajt bilo šta od 1 do 255, onda se to šalje na lokalni mrežni interfejs (za ovaj interfejs je često fabrički i neraskidivo vezan svič)</li>
<li>Sve ostalo ide na WAN interfejs ka vašem provajderu.</li>
</ul></li>
<li>Kompleksniji ruteri imaju kompleksnija pravila ali statičke tabele rutiranja imaju ograničenu upotrebnu vrednost</li>
</ul>
</section>
<section id="dinamičko-rutiranje-2" class="slide level2">
<h2>Dinamičko rutiranje</h2>
<ul>
<li>Zamislite da vam je jako bitan internet protok i zato plaćate račune kod dva provajdera</li>
<li>Onda vam treba ruter sa <em>tri</em> mrežna interfejsa</li>
<li>Takođe vam treba pravilo kada koji paketi idu kroz koji link</li>
<li>Oba WAN linka vode, potencijalno, ka celom ostatku interneta</li>
<li>Pravilo zavisi od potreba sistema, uspostavljenih veza i brda drugih faktora</li>
<li>Treba vam dinamičko rutiranje</li>
</ul>
</section>
<section id="dinamičko-rutiranje-3" class="slide level2">
<h2>Dinamičko rutiranje</h2>
<ul>
<li>Za provajdere situacija je još komplikovanija</li>
<li>Imaju razne linkove ka raznim drugim mrežama</li>
<li>Potencijalno imaju više linkova ka istoj drugoj mreži</li>
<li>Svaki link je jednako dobar u smislu toga što će, eventualno, sve što pošalju da stigne tamo gde treba</li>
<li>Ali koja putanja je adekvatno brza?</li>
</ul>
</section>
<section id="dinamičko-rutiranje-4" class="slide level2">
<h2>Dinamičko rutiranje</h2>
<ul>
<li>Ruteri u ovakvim situacijama koriste kompleksne algoritme koji na osnovu topologije veza i trenutnog stanja linkova dinamički biraju odredište za bilo koji specifičan paket</li>
<li>Faktori koji utiču na ‘sudbinu’ paketa su, naravno, adresa, veličina, i tajming, baš kao i trenutno stanje mreže i njenog opterećenja</li>
<li>Jednako bitno kao i sve ovo je i faktor poznat kao QoS</li>
</ul>
</section>
<section id="quality-of-service" class="slide level2">
<h2> Quality of Service </h2>
<ul>
<li>Ovaj termin se koristi u dva konteksta
<ul>
<li>Kvalitet komunikacije između neke dve tačke u mrežnom sistemu</li>
<li><em>Traženi</em> kvalitet komunikacije</li>
</ul></li>
<li>Ako uređaj kaže da podržava QoS onda se misli na značenje 2</li>
<li>Kada ima više paketa, sistem može birati da odabere neke kao hitnije u odnosu na druge</li>
</ul>
</section>
<section id="uticaj-ovih-faktora-na-cc" class="slide level2">
<h2>Uticaj ovih faktora na CC</h2>
<ul>
<li>Dva mrežna faktora su glavna u slučaju komunikacije za računarstvo u oblaku:
<ul>
<li>Protok</li>
<li>Kašenjenje</li>
</ul></li>
<li>Protok je količina informacija koja teče između neke dve tačke (vašeg sistema u oblaku i krajnjeg korisnika)</li>
<li>Kašenjenje je koliko vremena prođe od zahteva za podacima i prvih podataka koji stignu, tipično se meri u milisekundama</li>
</ul>
</section>
<section id="uticaj-ovih-faktora-na-cc-1" class="slide level2">
<h2>Uticaj ovih faktora na CC</h2>
<ul>
<li>Protok je problem ako komunikacija nadmaši kapacitet linka</li>
<li>Ovo se može rešiti novčano, tako što se zakupi još kapaciteta</li>
<li>Jedini rizik je u slučaju prenosa velikih količina podataka gde postoje i ekonomski faktori i faktori kapaciteta infrastrukture</li>
<li>Kašnjenje je mnogo veći problem</li>
</ul>
</section>
<section id="kašnjenje-i-otvoreni-internet" class="slide level2">
<h2>Kašnjenje i otvoreni internet</h2>
<ul>
<li>Nemoguće je  a priori  ustanoviti kojom će putanjom da ide nekakav podatak kroz mrežu sa dinamičkim rutiranjem koja je dovoljno kompleksna.</li>
<li>To znači da je kašnjenje bilo kog paketa nepredvidivo u zavisnosti od smera u kome dinamičko rutiranje pošalje neki ključan paket</li>
<li>Čak i ako postoje QoS garancije, vrlo je teško održati te tokom prolaska kroz domene nekoliko različitih provajdera</li>
<li>Ovo znači da je CC rešenje za probleme gde je potrebno vrlo malo kašnjenje neprikladno.</li>
</ul>
</section>
<section id="moguća-rešenja" class="slide level2">
<h2>Moguća rešenja</h2>
<ul>
<li>Jedini način da se utiče na kašnjenje jeste ako je moguće nešto uraditi povodom mrežne topologije obe strane komunikacije</li>
<li>Dakle, ne u slučaju krajnjeg korisinika, ali možda u slučaju komuinikacije dva sistema</li>
<li>Tajna može biti da se sistemi smeste bliže u kontekstu mrežne topologije</li>
<li>Alternativa je upotreba više provajdera usluga računarstva u oblaku</li>
</ul>
</section></section>
<section>
<section id="tehnologije-računarskih-postrojenja" class="title-slide slide level1">
<h1>Tehnologije računarskih postrojenja</h1>
<p>Industrijalizacija računarskih postrojenja</p>
</section>
<section id="šta-je-računarsko-postrojenje" class="slide level2">
<h2>Šta je računarsko postrojenje</h2>
<ul>
<li>Računarsko postrojenje jeste prostor, infrastruktura, i oprema koji su namenjeni za pružanje računarskih usluga na skali industrije</li>
<li>To znači da je organizacija prostorija, prisutna infrastruktura, i korišćene tehnologije sva isključivo namenjena navedenoj svrsi, bez kompromisa</li>
<li>Ovako nešto je neophodno da bi bilo isplativo da se održavaju dovoljno velike koncentracije računarskih kapaciteta da bi njihovo prodavanje kao usluge računarstva u oblaku imalo smisla.</li>
</ul>
</section>
<section id="modifikacija-prostora" class="slide level2">
<h2>Modifikacija prostora</h2>
<ul>
<li>Tipično za ovakav prostor je da očekujete posebno spuštene tavanice i podignute podove radi lakšeg provlačenja kablova i kontrolisanja sistema za hlađenje.</li>
<li>Koriste se napredni protivpožarni sistemi koji ponekad koriste tehnike izmeštanja kiseonika</li>
<li>Posebni sistemi napajanja</li>
</ul>
</section>
<section id="modularizacija" class="slide level2">
<h2>Modularizacija</h2>
<ul>
<li>Generalno svi računari u ovoj primeni su apsolutno standardizovanog oblika i napravljeni da idu na standardni rek za mrežnu opremu</li>
<li>Standardni rek je 19 inča (482.6  mm)  u unutarnjoj širini i definiše ga međunarodni standard  IEC 60297 </li>
<li>Isti standard specificira ‘rek jedinicu’ koja se tipično označava sa U</li>
<li>Jedan U je 44.45 mm odnosno jedan i tri četvrt inča i jedinice visine na reku su umnožak ove vrednosti</li>
<li>Standardni rek je 42U visok</li>
</ul>
</section>
<section id="modularizacija-1" class="slide level2">
<h2>Modularizacija</h2>
<ul>
<li>Ideja je da se hardver može smestiti optimizovanim radosledom i rasporedom bez brige da nešto neće stati</li>
<li>Ovo je naročitno bitno zato što se očekuje da će delovi sistema morati brzo i lako da se menjaju, a standardizacija znači da je pristup individualnim koimponentama brz i relativno bezbolan.</li>
</ul>
</section>
<section id="automatizacija-i-udaljen-rad" class="slide level2">
<h2>Automatizacija i udaljen rad</h2>
<ul>
<li>Računarska postrojenja su maksimalno automatizovana i često mogu da operišu polu-autonomno, pokrećući još računara kada je to potrebno i gaseći one koji nisu</li>
<li>Jednako automatizovano je i kreiranje novih sistema sa mehanizmima automatskog boot mehanizma preko mreže i headless instalacijama, što omogućava ne samo podizanje virtuelne mašine automatski nego čak i instalaciju na ‘metalu’</li>
<li>Kada je i potrebna ljudska interakcija, ona je kade god je to moguće, odrađena udaljeno koristeći obezbeđen link za transfer komandi.</li>
<li>Jedino mesto gde je ljudska interakcija neminovna jeste rešavanje hardverskih problema.</li>
</ul>
</section>
<section id="pouzdanost" class="slide level2">
<h2>Pouzdanost</h2>
<ul>
<li>Kada je u pitanju pravljenje računarskog postrojenja koje je jako otporno na otkaz, vodeće pravilo je  one is none </li>
<li>Drugim rečima, ne dozvoljavaju se jedinstvene tačke otkaza  (SPOF)  i svi ključni sistemi su duplirani</li>
<li>U slučaju, na primer, servera, tipično je imati dva potpuno odvojena, posebna napajanja gde jedno od njih služi manje-više isključivo da ima izvor struje spreman na licu mesta istog trenutka kada primarni izvor otkaže</li>
</ul>
</section>
<section id="bezbednost" class="slide level2">
<h2>Bezbednost</h2>
<ul>
<li>Budući da se računarski resursi (pa i podaci koje smeštaju i obrađuju) nalaze na jednom centralnom mestu lakše je fizički obezbediti uređaje</li>
<li>Fizička zaštita servera je izuzeztno bitna</li>
<li>Većina računarskih sistema nema nikakvu zaštitu od direktnog fizičkog pristupa</li>
<li>Rešenja su rigorozna fizička bezednost, bezbednosni protokoli</li>
<li>Podaci u mirovanju valja da budu enkriptovani da bi zaštitili sistem od krađe podataka direktnim putem</li>
</ul>
</section>
<section id="prilagođen-primarni-hardver" class="slide level2">
<h2>Prilagođen primarni hardver</h2>
<ul>
<li>Primarni hardver sistema su njegovi element sposobni za proračune</li>
<li>Ovi su prilagođeni industrijskoj eksploataciji</li>
<li>Veće performanse</li>
<li> Hot-swap  mehanizmi</li>
<li>Povećana pouzdanost</li>
</ul>
</section>
<section id="prilagođen-hardver-za-čuvanje-podataka" class="slide level2">
<h2>Prilagođen hardver za čuvanje podataka</h2>
<ul>
<li>Jedan od velikih poslova bilo kog računarskog centra je čuvanje ogromnih količina podataka</li>
<li>Ovo zahteva posebnu tehnologije</li>
<li>Prva stavka jeste kako će se uređaji za čuvanje podataka spojiti sa sistemom, glaven dve opcije su:
<ul>
<li> DAS (device attached storage)  što znači da je uređaj zakačen direktno za primarni hardver kroz  host bus adapter (HBA)  što odgovara klasičnom slučaju diska zakačenog za računar.</li>
<li> NAS (network attached storage  - u širem smislu) što znači da je uređaj zakačen za nekakvu mrežu na koju se kače uređaji primarnog hardvera</li>
</ul></li>
</ul>
</section>
<section id="nas" class="slide level2">
<h2>NAS</h2>
<ul>
<li>Ako pravimo mrežu diskova imamo izbor da li povezujemo <em>direktno</em> diskove i omogućavamo da se tom umreženom sistemu pristupa u blok-po-blok režimu ili da postoji poseban uređaj koji upravlja diskovima, a preko mreže se pristupa na nivou individualnog fajla.</li>
<li>Prvi pristup se zove SAN  (storage area network)  i implementira se kroz tehnologije kao što je SCSI ili  Fibre Channel  ili  Fibre Channel over Ethernet  ili  InfiniBand </li>
<li>Drugi pristup je NAS u užem smislu i koristi se ista mreža kao i za sve ostalo sa protokolima koji operišu na nivou fajla kao što su SMB ili NFS</li>
</ul>
</section>
<section id="kombinacija-diskova" class="slide level2">
<h2>Kombinacija diskova</h2>
<ul>
<li>Jedan disk nema zadovoljavajuće karakteristike kada je CC u pitanju</li>
<li>Nije dovoljno velik, brz, ili pouzdan</li>
<li>Srećom moguće je kombinovati diskove na načine koji povećavaju sve ove osobine</li>
<li>%RAID%, JBOD ili napredni fajl sistemi kao što je btrfs</li>
</ul>
</section>
<section id="prilagođen-mrežni-hardver" class="slide level2">
<h2>Prilagođen mrežni hardver</h2>
<ul>
<li>Računarskim centrima je potreban jako brz mrežni pristup, kao što smo pričali</li>
<li>To se rešava redudantnim vezama kao i jako brzim mrežnim tehnologijama</li>
<li>Optika se jako često koristi gde se jedno optičko vlakno može koristiti da, multipleksirano, prenosi sav saobraćaj mnogo gigabitnih mrežnih linkova.</li>
</ul>
</section>
<section id="mrežni-hardver-svestan-sadržaja" class="slide level2">
<h2>Mrežni hardver svestan sadržaja</h2>
<ul>
<li>U potrebi za većom brzinom koriste se često posebni mrežni elementi koji služe da ubrzavaju web</li>
<li>To se radi tako što se mrežni transport osposobi da razume šta paketi rade na aplikativnom nivou</li>
<li>Ovo znači da se podaci mogu preprocesirati ili enkriptovati/dekriptovati još u mreži</li>
<li>Naročito bitno je znati čemu su paketi namenjeni što omogućava da se radi efektno balansiranje opterećenja</li>
</ul>
</section></section>
<section>
<section id="virtualizacija" class="title-slide slide level1">
<h1>Virtualizacija</h1>
<p>Zamišljeni a stvarni računari.</p>
</section>
<section id="šta-je-virtualizacija" class="slide level2">
<h2>Šta je virtualizacija</h2>
<ul>
<li>Virtualizaicja je mehanizam kojim se jedan fizički računar ponaša kao više nezavisnih računarskih sistema koji su potpuno odvojeni.</li>
<li>Virzualizacija nema jako dobro rešenje zato što računari već decenijama rade ovaj trik na ovaj način ili onaj</li>
<li>Procesi, na kraju krajeva, su barem delimično odeljeni i ponašaju se (donekle) kao ‘sami na svetu’ što se tiče memorije</li>
<li>Još teže je konceptualno odvojiti virtuelizaciju od <em>emulacije</em></li>
</ul>
</section>
<section id="emulacija-i-virtuelizacija" class="slide level2">
<h2>Emulacija i virtuelizacija</h2>
<ul>
<li>Mogućnost jednog računarskog sistema da se pretvara da je drugi računarski sistem je nešto što je ugrađeno u same osnove ove oblasti</li>
<li>Čerč-Tjuringova teza znači da, performanse i prostor na stranu, bilo koji računarski sistem se može u principu ponašati kao bilo koji drugi računarski sistem</li>
<li>U najgorem slučaju, vi možete napisati emulator koji replicira ponašanje bilo kakvog digitalnog čipa u sistemu apsolutno tačno</li>
<li>Čak i postoje emulatori za, npr. neke stare igračke mašine koje imaju ovaj nivo granualrnosti</li>
</ul>
</section>
<section id="razlika-između-emulacije-i-virtualizacije" class="slide level2">
<h2>Razlika između emulacije i virtualizacije</h2>
<ul>
<li>Razlika nije u nameni ili čak i efektu nego u tehnologiji i očekivanim performansama</li>
<li>Ako nešto opisujemo kao virtuelizovano to znači da očekujemo performanse koje su uporedive sa performansama pravog sistema</li>
<li>Sa druge strane, voljni smo da prihvatimo ograničenja</li>
<li>PC može da <em>emulira</em> 6502 čip, ali ga nikad neće virtuelizovati</li>
</ul>
</section>
<section id="najopštija-definicija-virtuelizacije" class="slide level2">
<h2>Najopštija definicija virtuelizacije</h2>
<ul>
<li>Ova sekcija je uglavno o virtuelizaciji računarskih sistema</li>
<li>Strikno govoreći skoro bilo koji servis se može ‘virtualizovati’</li>
<li>Ova najšira forma virtuelizacije je mehanizam kojim se heterogeno polje resursa predstavlja krajnjem koisniku kao nešto homogeno</li>
<li>Divan primer je elektrosnadbevanje: kranji potrošač ne zna da li je struja poreklom iz termoelekgrane, hidroelektrane, nuklearne elektrane…</li>
<li>Ceo taj kapacitet generacije, skladištenja, transporta, itd. je apstrahovan kroz virtuelizaciju.</li>
</ul>
</section>
<section id="bazična-arhitektura-virtualizacije" class="slide level2">
<h2>Bazična arhitektura virtualizacije</h2>
<ul>
<li>Virtualna mašina (Od sada VM) se koncipira kao da je stvaran računar koji se u stvarnosti nalazi na nekvom fizičkom računaru koji se obično zove ‘domaćniski’ odnosno host računar.</li>
<li>Za taj host računar kažemo i da ima host operativni sistem.</li>
<li>Konsekventno, VM onda postaje računar-gost, odnosno guest računar i ima svoj, guest operativni sistem.</li>
<li>Ključna osobina tehnike virtuelizacije jeste da guest operativni sistem i sav softver koji se izvršava na njemu <em>ne zna</em> da je na VM-u, a ne na fizičkom računaru.</li>
</ul>
</section>
<section id="da-li-vm-zna-da-je-vm" class="slide level2">
<h2>Da li VM zna da je VM?</h2>
<ul>
<li>Ovo nije 100% istina</li>
<li>Tipično, sofver apsolutno ne zna da li je u virtuelnoj mašini ili ne</li>
<li>Operativni sistemi, donekle, jesu svesni da su u promenjenom okruženju</li>
<li>Ovo nije neophodno, ali se često operativni sistemi podifikuju ne bi li se dobile bolje performanse</li>
<li>Tipićan primer: Guest Additions</li>
</ul>
</section>
<section id="šta-omogućava-virtuelizaciju" class="slide level2">
<h2>Šta omogućava virtuelizaciju?</h2>
<ul>
<li>Virtuelizacija je omogućena kroz mehanizam koji upravlja servisima virtuelizacije</li>
<li>Ovaj mahanizam ima različita imena: Meandžer virtuelnih mašina, Monitor virtuelnih mašina, ali najčešće je poznat pod standardni industrijskim nazivom ‘Hipervizor’ (eng.  Hypervisor) </li>
<li>Da bi razumeli ovaj malo čudni naziv valja napomenuti da se kernel operativnog sistema vrlo često zove supervisor</li>
<li>Stoga nešto iznad super mora biti hyper</li>
</ul>
</section>
<section id="tipovi-hipervizora" class="slide level2">
<h2>Tipovi hipervizora</h2>
<ul>
<li>Hipervizori dolaze u dve glavne forme, hipervizori tipa 1, i hipervizori tipa 2</li>
<li>Ovo se ponekad još zovu i hipervizori ‘golog metala’ i ‘ugošćeni’ hipervizori</li>
<li>Engleski termini su  bare metal  i hosted</li>
<li>Ova podela nije nužno iscrpna</li>
</ul>
</section>
<section id="hipervizori-tipa-1" class="slide level2">
<h2>Hipervizori tipa 1</h2>
<ul>
<li>Hipervizor tipa 1 se izvršava direktno na hardveru, bez bilo čega ispod sebe</li>
<li>To znači da takav hipervizor ima određene osobine operativnog sistema, ali nije klasičan operativni sistem</li>
<li>Ovo je najperformantnija forma zato što ima što manje između vritualne mašine i stvarnog hardvera</li>
<li>Primeri hipervizora tipa 1 su Xen i VMware ESXi</li>
</ul>
</section>
<section id="hipervizori-tipa-2" class="slide level2">
<h2>Hipervizori tipa 2</h2>
<ul>
<li>Hipervizor tipa 2 se izvršava kao proces operativnog sistema</li>
<li>Ovo ima bezbednosne prednosti (zato što je proces dodatno ograničen na način na koji hipervizor tipa 1 ne može biti), i olakšava primenu takvog sistema na računarima za ličnu upotrebu ili na računarima mešane upotrebe</li>
<li>Glavna mana hipervizora tipa 2 jesu performanse: pošto svaki sistemski poziv esencijalo poziva emulirani sloj hardvera koji poziva sistemske pozive operativnog sisteam domaćina koji poziva stvarni hardver, generalno performanse hipervizora tipa 2 su <em>znatno</em> lošije</li>
<li>Primer koji je vama <em>jako</em> poznat bi trebao da je VirtualBox</li>
</ul>
</section>
<section id="hipervizori-tipa-1.5" class="slide level2">
<h2>Hipervizori tipa… 1.5?</h2>
<ul>
<li>Ova podela izgleda iscrpno ali nije</li>
<li>Šta recimo uraditi sa KVM mehanizmom</li>
<li>KVM mehanizam je modul koji se dodaje u kernel Linux operativnog sistema koji efektivno pretvara Linux u hipervizor prvog tipa</li>
<li>Drugim rečima dozvoljava aplikacijama koje se izvršavaju na nivou korisnika da zatraže da se nešto virtuelizuje na ‘metalu’ umesto u korisničkom prostoru (Tipična kombinacija i ona koja pokreće VM u kojem se pišu baš ove reči je  QEMU/KVM) </li>
</ul>
</section>
<section id="pitanje-hardvera" class="slide level2">
<h2>Pitanje hardvera</h2>
<ul>
<li>Ovaj mehanizam funkcioniše utoliko ukoliko može da izvršava kod odvojeno i može da drži memoriju odvojeno ali udara u problem čim treba da se uradi bilo šta vezano za ulaz/izlaz</li>
<li>Nemoguće je jednostavno nekomplikovano premeštati ove stvari direktno u pravi hardver: ako imamo deset VM-ova i samo jedan disk, ko dobije da piše u superblok? Čiji je koji mrežni paket?</li>
<li>Jedino rešenje jeste da se hardver emulira</li>
</ul>
</section>
<section id="emulirani-hardver" class="slide level2">
<h2>Emulirani hardver</h2>
<ul>
<li>Svi hardverski uređaji zakačeni za VM postoje kao emulirane softverske apstrakcije</li>
<li>Tipičan primer je QEMU</li>
<li>QEMU je emulator sistema (ima i druge funkcije, ali je ova najzanimljivija)</li>
<li>Ono što ga čini posebno zanimljivim jeste da je to potpun emulator sa opcionom primenom hipervizora</li>
</ul>
</section>
<section id="potpun-emulator-sa-opcionom-primenom-hipervizora" class="slide level2">
<h2>Potpun emulator sa opcionom primenom hipervizora</h2>
<ul>
<li>Šta ovo znači?</li>
<li>Znači da QEMU može <em>ili</em> da emulira sav hardver na računaru što uključuje i procesor <em>ili</em> da emulira sve osim procesora koji se onda virtuelizuje kroz neki hipervizor, recimo  KVM. </li>
<li>Ovo znači da možemo da sastavimo virtuelnu konfiguraciju kada pokrećemo virtuelnu mašinu</li>
</ul>
</section>
<section id="o-ilustraciji" class="slide level2">
<h2>O ilustraciji</h2>
<ul>
<li>Svaka virtuelna mašina emulira <em>nešto</em></li>
<li>Mi ovde koristimo kao primer nešto što je lako testirati u kućnoj radinosti</li>
<li>Sve što vam treba je noviji Linux ali instaliran kao host operativni sistem</li>
<li>Primer koji mi koristimo je KVM (kao hipervizor), QEMU kao emulator, i libvirt kao API sloj za upravljanje virtuelnim mašinama.</li>
</ul>
</section>
<section id="libvirt" class="slide level2">
<h2>Libvirt</h2>
<ul>
<li>libvirt nismo do ovog trenuka pominjali</li>
<li>On sam po sebi ne daje neke nove sposobnosti, koliko pruža uniformni način da se specificira ponašanje virtuelnih mašina</li>
<li>Obuhvata brdo elemenata i faktora, ali nas će najviše zanimati ugrađeni XML jezik za opis konfiguracije virtuelnih mašina</li>
</ul>
</section>
<section id="domeni" class="slide level2">
<h2>Domeni</h2>
<ul>
<li>Bilo šta što emulira, libvirt zove ‘Domen’</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">domain</span><span class="ot"> type=</span><span class="st">&#39;kvm&#39;</span><span class="ot"> id=</span><span class="st">&#39;1&#39;</span>&gt;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">name</span>&gt;MyGuest&lt;/<span class="kw">name</span>&gt;</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">uuid</span>&gt;4dea22b3-1d52-d8f3-2516-782e98ab3fa0&lt;/<span class="kw">uuid</span>&gt;</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">genid</span>&gt;43dc0cf8-809b-4adb-9bea-a9abb5f3d90e&lt;/<span class="kw">genid</span>&gt;</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">title</span>&gt;A short description - title - of the domain&lt;/<span class="kw">title</span>&gt;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">description</span>&gt;Some human readable description&lt;/<span class="kw">description</span>&gt;</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">metadata</span>&gt;</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">app1:foo</span><span class="ot"> xmlns:app1=</span><span class="st">&quot;http://app1.org/app1/&quot;</span>&gt;..&lt;/<span class="kw">app1:foo</span>&gt;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">app2:bar</span><span class="ot"> xmlns:app2=</span><span class="st">&quot;http://app1.org/app2/&quot;</span>&gt;..&lt;/<span class="kw">app2:bar</span>&gt;</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  &lt;/<span class="kw">metadata</span>&gt;</span></code></pre></div>
<p>(Primeri iz <a href="https://libvirt.org/formatdomain.html">https://libvirt.org/formatdomain.html</a>)</p>
</section>
<section id="emulacija-procesora" class="slide level2">
<h2>Emulacija procesora</h2>
<ul>
<li>Za %Cloud Computing% nema velike koristi od emulacije procesora</li>
<li>To je od koristi prilikom razvoja za egzotične platforme, eksperimenata, softverske arheologije…</li>
<li>Prvi korak je promeniti tip domena tako da više ne koristi hipervizor, vrednost qemu recimo.</li>
<li>Zatim se mora podesiti željeni oblik procesora</li>
</ul>
</section>
<section id="željeni-oblik-procesora" class="slide level2">
<h2>Željeni oblik procesora</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">cpu</span><span class="ot"> match=</span><span class="st">&#39;exact&#39;</span>&gt;</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">model</span><span class="ot"> fallback=</span><span class="st">&#39;allow&#39;</span>&gt;core2duo&lt;/<span class="kw">model</span>&gt;</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">vendor</span>&gt;Intel&lt;/<span class="kw">vendor</span>&gt;</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">topology</span><span class="ot"> sockets=</span><span class="st">&#39;1&#39;</span><span class="ot"> dies=</span><span class="st">&#39;1&#39;</span><span class="ot"> cores=</span><span class="st">&#39;2&#39;</span><span class="ot"> threads=</span><span class="st">&#39;1&#39;</span>/&gt;</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">cache</span><span class="ot"> level=</span><span class="st">&#39;3&#39;</span><span class="ot"> mode=</span><span class="st">&#39;emulate&#39;</span>/&gt;</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">maxphysaddr</span><span class="ot"> mode=</span><span class="st">&#39;emulate&#39;</span><span class="ot"> bits=</span><span class="st">&#39;42&#39;</span>/&gt;</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">feature</span><span class="ot"> policy=</span><span class="st">&#39;disable&#39;</span><span class="ot"> name=</span><span class="st">&#39;lahf_lm&#39;</span>/&gt;</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>&lt;/<span class="kw">cpu</span>&gt;</span></code></pre></div>
</section>
<section id="virtualizacija-kroz-hipervizor-i-procesor" class="slide level2">
<h2>Virtualizacija kroz hipervizor i procesor</h2>
<ul>
<li>Kada želimo da ne emuliramo procesor no da koristimo onaj koji je već u mašini kao da je i u virtuelnoj mašini, barem što se tiče sposobnosti što se tiče, npr. pod-funkcionalnosti, onda moramo da kažemo da korsitimo isti procesor kao onaj koji je već na mašini</li>
<li>Srećom postoji prečica za ovo</li>
</ul>
</section>
<section id="prečica" class="slide level2">
<h2>Prečica</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>&lt;<span class="kw">cpu</span><span class="ot"> mode=</span><span class="st">&quot;host-model&quot;</span><span class="ot"> check=</span><span class="st">&quot;partial&quot;</span>/&gt;</span></code></pre></div>
<p>Ovo samo kopira ponašanje stvarnog fizičkog modela procesora na virtualizovani (ali ne emulirani) procesor</p>
</section>
<section id="alokacija-procesora" class="slide level2">
<h2>Alokacija procesora</h2>
<ul>
<li>Ne valja da svaka virtuelna mašina nužno ima apsolutno iste resurse na raspolaganju</li>
<li>Ponekad želimo da uradimo baš ono što nam CC obećava: agregiramo resurse na jednom mestu i particionišemo ih na drugom</li>
<li>Srećom to je moguće: kod virtualizacije mogu da se sistemu dodele virtuelna procesorska jezgra, a da se ta virtuelna jezgra izvršavaju na onim jezgrima fizičkog procesora koja su odabrana</li>
</ul>
</section>
<section id="primer-alokacije-virtuelnih-procesora" class="slide level2">
<h2>Primer alokacije virtuelnih procesora</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">vcpu</span><span class="ot"> placement=</span><span class="st">&#39;static&#39;</span><span class="ot"> cpuset=</span><span class="st">&quot;1-4,^3,6&quot;</span><span class="ot"> current=</span><span class="st">&quot;1&quot;</span>&gt;2&lt;/<span class="kw">vcpu</span>&gt;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  &lt;<span class="kw">vcpus</span>&gt;</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">vcpu</span><span class="ot"> id=</span><span class="st">&#39;0&#39;</span><span class="ot"> enabled=</span><span class="st">&#39;yes&#39;</span><span class="ot"> hotpluggable=</span><span class="st">&#39;no&#39;</span><span class="ot"> order=</span><span class="st">&#39;1&#39;</span>/&gt;</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">vcpu</span><span class="ot"> id=</span><span class="st">&#39;1&#39;</span><span class="ot"> enabled=</span><span class="st">&#39;no&#39;</span><span class="ot"> hotpluggable=</span><span class="st">&#39;yes&#39;</span>/&gt;</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  &lt;/<span class="kw">vcpus</span>&gt;</span></code></pre></div>
</section>
<section id="primer-alokacije-virtuelnih-procesora-1" class="slide level2">
<h2>Primer alokacije virtuelnih procesora</h2>
<ul>
<li>Ovo statički alocira 2 virtuelna procesora za koja su odgovorna fizička jezgra iz skupa 1-4, ne računajući jezgro 3, i dodatno jezgro 6.</li>
<li>Zatim specificira detalje ponašanja oba virtuelna CPU-a.</li>
</ul>
</section>
<section id="emulacija-blokovskih-uređaja" class="slide level2">
<h2>Emulacija blokovskih uređaja</h2>
<ul>
<li>Procesori nisu problem, mnogo ozbiljnije pitanje jeste šta uraditi kada je u pitanju, recimo, disk</li>
<li>Da bi instalirali vaš guest operativni sistem, morate imati nekakav disk</li>
<li>libvirt će specificirati a QEMU emulirati onakav disk kakav vi odlučite da imate</li>
</ul>
</section>
<section id="emulacija-blokovskih-uređaja-1" class="slide level2">
<h2>Emulacija blokovskih uređaja</h2>
<div class="sourceCode" id="cb5"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">disk</span><span class="ot"> type=</span><span class="st">&quot;file&quot;</span><span class="ot"> device=</span><span class="st">&quot;disk&quot;</span>&gt;</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>      &lt;<span class="kw">driver</span><span class="ot"> name=</span><span class="st">&quot;qemu&quot;</span><span class="ot"> type=</span><span class="st">&quot;qcow2&quot;</span>/&gt;</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>      &lt;<span class="kw">source</span><span class="ot"> file=</span><span class="st">&quot;/putanja/do/fajla/gde/je/disk&quot;</span>/&gt;</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>      &lt;<span class="kw">target</span><span class="ot"> dev=</span><span class="st">&quot;vda&quot;</span><span class="ot"> bus=</span><span class="st">&quot;virtio&quot;</span>/&gt;</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>      &lt;<span class="kw">address</span><span class="ot"> type=</span><span class="st">&quot;pci&quot;</span><span class="ot"> domain=</span><span class="st">&quot;0x0000&quot;</span><span class="ot"> bus=</span><span class="st">&quot;0x04&quot;</span><span class="ot"> slot=</span><span class="st">&quot;0x00&quot;</span><span class="ot"> function=</span><span class="st">&quot;0x0&quot;</span>/&gt;</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    &lt;/<span class="kw">disk</span>&gt;</span></code></pre></div>
</section>
<section id="emulacija-blokovskih-uređaja-2" class="slide level2">
<h2>Emulacija blokovskih uređaja</h2>
<ul>
<li>Ovo je emuliran disk kome je na host mašini u pozadini običan fajl</li>
<li>Specifično to je fajl tipa qcow2</li>
<li>To je poseban format diska optimiziovan za ovaj slučaj</li>
<li>Karakteriše ga odlična implementacija  copy on write  semantike</li>
<li>Fajl se povećava tek kada postoji prava potreba za prostorom na disku što smanjuje bačen prostor</li>
</ul>
</section>
<section id="problem-sa-emulacijom-hardvera" class="slide level2">
<h2>Problem sa emulacijom hardvera</h2>
<ul>
<li>Emulacija hardvera je <em>spora</em></li>
<li>Ovo je naročito nezgodno kod bilo koje  I/O  operacije</li>
<li>Još je gore ako je VM namenjen za interaktivno korišćenje</li>
<li>Postoje dva moguća rešenja:
<ul>
<li>Paravirtualizacija</li>
<li>Prespoj na nivou uređaja</li>
</ul></li>
</ul>
</section>
<section id="paravirtualizacija" class="slide level2">
<h2>Paravirtualizacija</h2>
<ul>
<li>Paravirtualizacija (PV) je tehnika gde, umesto da je proces virtuelizacije potpuno transparentan za operativni sistem - gost, taj operativni sistem je modifikovan da bi mogao lakše da se virtuelizuje</li>
<li>Ovo ima dve forme
<ul>
<li>Potpuna paravirtuelizacija</li>
<li>Parcijalna paravirtuelizacija</li>
</ul></li>
</ul>
</section>
<section id="potpuna-paravirtuelizacija" class="slide level2">
<h2>Potpuna paravirtuelizacija</h2>
<ul>
<li>Ovde je ceo operativni sistem modifikovan na najdubljem nivou da funkcioniše u virtuelizovanom okruženju</li>
<li>Takav operativni sistem operiše u potpuno ne-transparentnom okruženju i na mestima gde bi, npr, pričao sa hardverom on jednostavno poziva sistemske pozive hipervizora (ponekad se koristi termin hypercalls mada je on relativno redak)</li>
<li>Takvi sistemi imaju i sekvencu pokretanja koja ‘zna’ da se ne pokreće prava mašina pa se ne bave nikavom inicijalizacijom hardvera (koji ne postoji) no se kod kernela pokreće istog trenutka</li>
</ul>
</section>
<section id="potpuna-paravirtuelizacija-1" class="slide level2">
<h2>Potpuna paravirtuelizacija</h2>
<ul>
<li>Potpuna paravirtualizacija je bila fantastično brza (komparativno) zato što, umesto da koristi osobine procesora i mikroarhitekture koje je relativno teško virtualizovati i emulirati, sistem jednostavno kaže hipervizoru šta želi i to se desi, veoma brzo i efektno</li>
<li>Sistem je i dalje transparentan prema softveru u korisničkom prostoru zato što se onaj deo operativnog sistema koji pruža interfejs prema korisničkim aplikacijama ne menja</li>
</ul>
</section>
<section id="smanjenje-važnosti-paravirtuelizacije" class="slide level2">
<h2>Smanjenje važnosti paravirtuelizacije</h2>
<ul>
<li>Jedno vreme, jedini praktičan način da se dobiju prihvatljive performanse prilikom virtuelizacije je bilo da se ‘vara’ kroz PV</li>
<li>Danas ovo više nije slučaj: potpuna PV je i dalje brza, kao i uvek, ali ju je alternativa (koja se često zove  HVM)  dostigla pa čak i prestigla u performansama</li>
</ul>
</section>
<section id="smanjenje-važnosti-paravirtuelizacije-1" class="slide level2">
<h2>Smanjenje važnosti paravirtuelizacije</h2>
<ul>
<li>Kako? Kroz tehnologiju procesora koje imaju posebne tehnike koje eliminišu potrebu da se neke stvari virtuelizuju u softveru</li>
<li>Ovo znači da se može očuvati nepromenjen procesor i ipak ostvariti performanse koje su ekvivalentne perofrmansama procesora na ‘golom metalu.’</li>
<li>PV je i dalje jedina praktična opcija ako nema hardverske podrške</li>
</ul>
</section>
<section id="parcijalana-paravirtualizacija" class="slide level2">
<h2>Parcijalana paravirtualizacija</h2>
<ul>
<li>Uprkos tome, paravirtualizacija se i dalje koristi samo u parcijalnoj formi</li>
<li>Uprkos dobrim performansama koje postiže HVM i dalje postoji usko grlo koje nas je dovelo ovde: simulirani hardver</li>
<li>Veliko je traćenje vremena što sistem mora da se pretvara da, na primer, priča sa potpuno fiktivnim hard diskom umesto da jednostavno pošalje zahtev za podacima koji su potrebni direktno hipervizoru koji to onda može proslediti gde treba</li>
</ul>
</section>
<section id="parcijalana-paravirtualizacija-1" class="slide level2">
<h2>Parcijalana paravirtualizacija</h2>
<ul>
<li>Uvid parcijalne paravirtualizacije (koja je još poznata pod terminom  PV on HVM  što je, recimo, kako to zove kompanija  Amazon)  jeste da je moguće promeniti samo <em>deo</em> operativnog sistema da bi dobili dobre performanse</li>
<li>Koji to deo operativnog sistema može da se promeni relativno lako? <strong>Drajveri</strong></li>
<li>Da stvar bude slađa, nama je potrebna paravirtuelizacija baš da bi radili  I/O  što, pak, se baš postiže kroz drajvere</li>
</ul>
</section>
<section id="parcijalana-paravirtualizacija-2" class="slide level2">
<h2>Parcijalana paravirtualizacija</h2>
<ul>
<li>Stoga, umesto da modifikujemo ceo operativni sistem, samo napišemo drajvere za naš virtuelni hardver koji, umesto da rade stvari sporo, rade stvari kroz paravirtuelizaciju i pozivaju hipervizorske sistemske pozive direktno</li>
<li>Ovim se može postići najbolje od svih svetova: sve performanse sa maksimalnom fleksibilnošću</li>
</ul>
</section>
<section id="primer-diska-opet" class="slide level2">
<h2>Primer diska (opet)</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode xml"><code class="sourceCode xml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    &lt;<span class="kw">disk</span><span class="ot"> type=</span><span class="st">&quot;file&quot;</span><span class="ot"> device=</span><span class="st">&quot;disk&quot;</span>&gt;</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>      &lt;<span class="kw">driver</span><span class="ot"> name=</span><span class="st">&quot;qemu&quot;</span><span class="ot"> type=</span><span class="st">&quot;qcow2&quot;</span>/&gt;</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>      &lt;<span class="kw">source</span><span class="ot"> file=</span><span class="st">&quot;/putanja/do/fajla/gde/je/disk&quot;</span>/&gt;</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>      &lt;<span class="kw">target</span><span class="ot"> dev=</span><span class="st">&quot;vda&quot;</span><span class="ot"> bus=</span><span class="st">&quot;virtio&quot;</span>/&gt;</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>      &lt;<span class="kw">address</span><span class="ot"> type=</span><span class="st">&quot;pci&quot;</span><span class="ot"> domain=</span><span class="st">&quot;0x0000&quot;</span><span class="ot"> bus=</span><span class="st">&quot;0x04&quot;</span><span class="ot"> slot=</span><span class="st">&quot;0x00&quot;</span><span class="ot"> function=</span><span class="st">&quot;0x0&quot;</span>/&gt;</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    &lt;/<span class="kw">disk</span>&gt;</span></code></pre></div>
</section>
<section id="primer-diska-opet-1" class="slide level2">
<h2>Primer diska (opet)</h2>
<ul>
<li>Ovde je već angažovana tehnika parcijalne paravirtuelizacije</li>
<li> QEMU/KVM  radi HVM virtuelizaciju, ali ima podršku za podsistem za parcijalni PV</li>
<li>Zaj podsistem ze zove virtio i on je ovde uključen</li>
</ul>
</section>
<section id="prespoj-na-nivou-uređaja" class="slide level2">
<h2>Prespoj na nivou uređaja</h2>
<ul>
<li> HVM + PPV  je moćna kombinacija ali ona radi samo gde se hardver i dalje virtuelizuje</li>
<li>Nekakav hardver nije baš tako lako virtuelizovati</li>
<li>Klasičan primer je GPU</li>
<li>Rešenje koje je formirano je korišćenje hardverskih funkcionalnosti (Ključne reči su  Vt-d  i  IOMMU  u zavisnosti od tehnologije) da se sva komunikacija između računara i fizičkog komada hardvera usmeri na jednu virtuelnu mašinu</li>
</ul>
</section>
<section id="prespoj-na-nivou-uređaja-1" class="slide level2">
<h2>Prespoj na nivou uređaja</h2>
<ul>
<li>Možete misliti o ovome kao o tehnici koja vam omogućava da ‘utaknete’ pravi hardver u virtuelnu mašinu</li>
<li>Može se raditi na nivou individualne PCI kartice, tipično to je GPU uređaj, ali u praksi može i nešto drugo</li>
<li>Može se raditi na nivou i individualnog USB uređaja kada se obično zove USB redirekcija</li>
<li>Ovo je tehnologija koja omogućava, npr. da se dobiju CC instance sa grafikom</li>
</ul>
</section>
<section id="moderni-standard" class="slide level2">
<h2>Moderni standard</h2>
<ul>
<li>Današnji standard za virtualizaciju koji postiže performanse koje se vrlo teško razlikuju od performansi bez virtualizacije jeste
<ul>
<li>%HVM&amp; za glavninu posla</li>
<li>PV parcijalno za emulirani hardver (Gde se emulira većina  I/O  hardvera)</li>
<li>Prespoj na nivou uređaja za GPU uređaje ako su potrebni</li>
</ul></li>
<li>Ovaj standard je sada već dostupan na praktično svakom operativnom sistemu i u serverskom i u lično-računarskom okruženju</li>
</ul>
</section>
<section id="kontejneri-i-virtuelne-mašine" class="slide level2">
<h2>Kontejneri i virtuelne mašine</h2>
<ul>
<li>Tehnika virtuelizacije je neizbežna i korisna</li>
<li>Ali za veliki broj slučajeva primećeno je da se VM tehnologija koristi da bi se u okviru operativnog sistema X pokreću druge instance istog operativnog sistema, samo da bi se individualne aplikacije držale ‘zatvorene’ u svojim okruženjima.</li>
<li>Ovo znači da su sposobnosti virtuelne mašine, sva ta mogućnost simuliranog hardvera, drugih operativnih sistema, transparentnosti i svega toga, fundamentalno bačena.</li>
</ul>
</section>
<section id="zašto-emulirati-linux-u-linux-u" class="slide level2">
<h2>Zašto emulirati Linux u  Linux-u? </h2>
<ul>
<li>Glavni razlog zašto se u produkciji pokreće virtuelna mašina koja je identična svom ‘domaćinskom’ sistemu je
<ul>
<li>Portabilnost</li>
<li>Ponovljivost</li>
<li>Izolacija</li>
</ul></li>
</ul>
</section>
<section id="portabilnost" class="slide level2">
<h2>Portabilnost</h2>
<ul>
<li>Da bi nekakva aplikacija radila potrebno je imati veliki broj potporno softvera: biblioteka, alata, servera, itd.</li>
<li>To znači da je vrlo teško poslati nekome aplikaciju</li>
<li>Kada je u pitanju distribucija aplikacija za korisničke sisteme često je potrebna ili kompleksna instalaciona procedura ili impersivno kompleksan sitem za menadžment paketima</li>
<li>Situacija za servere je još gora jer, osim što je potrebno sve to, mimo toga je još problem konflikta zahteva serverskih aplikacija</li>
</ul>
</section>
<section id="konflikt-zahteva" class="slide level2">
<h2>Konflikt zahteva</h2>
<ul>
<li>Serverske aplikacije se često izvršavaju u paraleli na istim mašinama sa mnogo drugih serverskih aplikacija</li>
<li>Problem sa ovim jeste što jedna aplikacija može da zahteva jednu verziju ključne biblioteke, a druga drugu</li>
<li>Čija je onda ‘starija?’</li>
<li>Čak i ako se taj problem reši kroz, recimo, virtualizaciju okruženja ili pakovanje zahteva, šta da se radi sa zahtevima sa različitim verzijama potpornog servera?</li>
<li>Recimo: šta ako imamo dve Java aplikacije gde svaka zahteva drugačiju verziju <code>Tomcat</code> servera?</li>
</ul>
</section>
<section id="konflikt-zahteva-1" class="slide level2">
<h2>Konflikt zahteva</h2>
<ul>
<li>A čak i ako se reši taj problem, ostaje problem interfejsa koji se ne mogu nikako replicirati</li>
<li>Šta raditi ako imamo dva web servera? Ko dobije portove 80 i 443?</li>
<li>Ovo sve dovodi do toga da je nemoguće samo ‘pokrenuti’ neku aplikaciju na datom serveru, no je to produžen i mučan proces koji zahteva jako puno konfiguracije i kompromisa i ne može da se lako automatizuje.</li>
<li>Budući da je ‘samo pokreni’ neophodan korak ako želimo CC u bilo kojoj formi, portabilnost kroz virtuelizaciju je neophodna</li>
</ul>
</section>
<section id="ponovljivost" class="slide level2">
<h2>Ponovljivost</h2>
<ul>
<li>Vrlo bitna stavka kada se softver nađe u produkciji jeste da ne može da se desi da se neki sitan element hardversko-softverske konfiguracije promeni i softver naprasno prestane da funkcioniše ili, možda još gore, počne da radi <em>drugačije</em></li>
<li>Ovo je boljka dobro poznata svakome u ovoj oblasti i zove se “Ali radi na mojoj mašini”</li>
<li>Stoga, pojavila se potreba da postoji nekakav recept (idealno takav da se može automatizovati) koji, ako se prati, proizvede <em>tačno</em> okruženje u kome aplikacija treba da radi</li>
</ul>
</section>
<section id="izolacija" class="slide level2">
<h2>Izolacija</h2>
<ul>
<li>Ne samo što želimo da sprečimo slučajne konflikte između aplikacije, takođe želimo da sprečimo namerne konflikte</li>
<li>Ako neko uspešno izvrši napad na bilo koji serverski proces na nekom sistemu i dobije šansu da šalje udaljene komande, apsolutno svi procesi na tom sistemu su sada ugroženi</li>
<li>Postoji separacija između procesa, ali ona (u podrazumevanom okruženju) je nesavršena
<ul>
<li>Što?</li>
</ul></li>
</ul>
</section>
<section id="izolacija-1" class="slide level2">
<h2>Izolacija</h2>
<ul>
<li>Izolacija između virtuelnih mašina je znatno bolja</li>
<li>I dalje je moguće, kako se to kaže, da se ‘pobegne’ iz virtuelne mašine, ali je ovo barem za red veličine teže i lakše za odbranu zato što je površina napada mnogo bolje definisana</li>
<li>Tako se potencijalno maliciozan sadržaj može držati ‘zarobljen’ što povećava bezbednost celog sistema</li>
</ul>
</section>
<section id="motivacija-za-konejnere" class="slide level2">
<h2>Motivacija za konejnere</h2>
<ul>
<li>Budući da nam ne treba poseban hardver, ne treba egzotična CPU arhitektura, i ne trebe nikakav novi operativni sistem, virtuelizacija ima dosta bačenih resursa</li>
<li>Da li bi mogla virtualizacija ali lakša po sistem, ograničena samo na separaciju userspace okruženja koja dele, nekako, kernel?</li>
<li>Ako da, kako bi to radilo?</li>
</ul>
</section>
<section id="opšta-ideja" class="slide level2">
<h2>Opšta ideja</h2>
<ul>
<li>Opšta ideja ovog problema se zove virtualizacija na nivou operativnog sistema</li>
<li>Umesto da se pretvaramo da imamo ceo nov računar, mi umesto toga ubedimo operativni sistem da se pretvara da je više različitih instalacija</li>
<li>Onda još samo ubedimo operativni sistem da se pretvara da je druga instalacija prema drugim procesima i time obezbeđujemo potpunu izolaciju</li>
</ul>
</section>
<section id="opšta-ideja-1" class="slide level2">
<h2>Opšta ideja</h2>
<ul>
<li>Možemo ovo da uradimo zato što procesi u korisničkom prostoru u potpunosti zavisni od operativnog sistema da otkriju šta se dešava</li>
<li>Ako operativni sistem ‘laže’ na sistemske pozive, program u korisničkom prostoru to ne može da otkrije</li>
<li>Jedini izazov jeste kako ubediti operativini sistem da drži konzistentne skupove laži i da govori prave laži pravom softveru</li>
<li>Zato se ovo uvek radi preko alata koji delimično imaju podršku na nivou kernela, a delimično kao alati u korisničkom prostoru.</li>
</ul>
</section>
<section id="preteča-chroot" class="slide level2">
<h2>Preteča – chroot</h2>
<ul>
<li>Najranija forma koja podseća na kontejner jeste koncept <code>chroot</code> u POSIX sistemima</li>
<li>Ova komanda (i sistemski poziv) služi da, kada se pokrene neki proces, može da mu se promeni šta je to tačno <code>root</code> direktorijum za njega</li>
<li>Ovo je način da se proces zarobi u hijerarhiju direktorijuma koja se odabere i taj proces ne može ni da imenuje (pa stoga ne može da otvori) fajlove fan te hijerarhije</li>
<li>Ovo znači da možemo da napravimo mini Linux instalacije za svaku aplikaciju gde svaka ima svoje zahteve prema fajlovima ispunjene.</li>
</ul>
</section>
<section id="ograničenja" class="slide level2">
<h2>Ograničenja</h2>
<ul>
<li>Naravno <code>chroot</code> je stara ideja i esencijalno ima vrlo slabu bezbednost i nikakav način da se zaštiti bilo šta <em>osim</em> fajlova</li>
<li>Uprkos tome, ovo je početak ove ideje i doveo je direktno to izuma, 1999, BSD <code>jail</code> komande koja omogućava da se sistem particioniše u ‘zatvore’ koji omogućavaju da se servisi sistema rigorozno odvoje jedni od drugih.</li>
<li>Za razliku od <code>chroot</code>, <code>jail</code> komanda ima i bezbednosne komponente i predstavlja nešto veoma blizu modernim kontejnerima.</li>
</ul>
</section>
<section id="tehnologija-iza-modernih-kontejnera" class="slide level2">
<h2>Tehnologija iza modernih kontejnera</h2>
<ul>
<li>Najčešće korišćeni modenri kontejneri proističu iz mehanizma koji se nalazi u modernim Linux kernel-ima i koji se zove <em>sistemski prostori imena</em> (eng.  namespaces ) </li>
<li>Ideja između sistemski prostora imena (SPI) jeste da je moguće definisati, unutar kernela, particije resursa sistema i prikazivati samo jednu particiju određenim procesima.</li>
<li>To znači da možemo imati dva procesa koji vide dva potpuno disjunktna skupa resursa</li>
</ul>
</section>
<section id="šta-se-može-sortirati-u-spi" class="slide level2">
<h2>Šta se može sortirati u SPI</h2>
<p>Linux poseduje osam tipova SPI: 1. <code>Cgroup</code> - Omogućava da svaki SPI vidi poseban set kontrolnih grupa koje Linux koristi da meri i ograničava resurse sistema 2. <code>IPC</code> - Omogućava da svaki SPI vidi poseban set resursa za komunikaciju između procesa 3. <code>Network</code> - Omogućava da svaki SPI vidi svoj sopstveni mrežni interfejs, pravila rutiranja, firewall i, generalno, ceo mrežni stek 4. <code>Mount</code> - Omogućava da svaki SPI vidi samo određeni podskup integrisanih sistema fajlova</p>
</section>
<section id="šta-se-može-sortirati-u-spi-1" class="slide level2">
<h2>Šta se može sortirati u SPI</h2>
<ol start="5" type="1">
<li><code>PID</code> - Omogućava da svaki SPI ima naizgled svoju tabelu procesa u kojoj se procesi drugih SPI ne nalaze</li>
<li><code>Time</code> - Omogućava da svaki SPI ima svoja podešavanja vezana za sistemsko vreme</li>
<li><code>User</code> - Omogućava da svaki SPI ima potpuno svoj set korisnika uključujući i ‘svog’ <code>root</code> korisnika i svoju interpretaciju dozvola za svoj pod-domen fajlova</li>
<li><code>UTS</code> - Omogućava da svaki SPI vidi potencijalno različit <code>hostname</code></li>
</ol>
</section>
<section id="kako-odavde-do-kontejnera" class="slide level2">
<h2>Kako odavde do kontejnera</h2>
<ul>
<li>Ako se resursi sistema rigorozno iseku na SPI i koristi se <code>chroot</code> da se neki proces zarobi u svoj pod-direktorijumu nešto što neodoljivo podseća na kontejner postaje moguće</li>
<li>Ovo znači da je moguće maltene generisati kontejner koristeći prostu komandu kojai je deo <code>utils-linux</code> paketa</li>
</ul>
</section>
<section id="unshare" class="slide level2">
<h2>Unshare</h2>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">unshare</span> <span class="at">-r</span> <span class="at">-i</span> <span class="at">-p</span> <span class="at">-f</span> <span class="at">--kill-child</span> <span class="at">-R</span> /home/veljko/tmp2 ./tst</span></code></pre></div>
</section>
<section id="objašnjenje" class="slide level2">
<h2>Objašnjenje</h2>
<ul>
<li><code>-r</code> podešava da će se korisnik unutar ovog našeg kontejnera mapirati na ‘root’ korisnika</li>
<li><code>-i</code> podešava da pravimo novi, odvojen IPC SPI</li>
<li><code>-p</code> podešava da pravimo novi, odvojen PID SPI</li>
<li><code>-f</code> podešava da pokrećemo potpuno nov proces sa ovom komandom za koji će biti podešeno sve što smo specificirali</li>
<li><code>--kill-child</code> grozomorno nazvana opcija koja kaže da se svi procesi-potomci terminiraju kada se terminira <code>unshare</code></li>
<li><code>-R</code> podešava nov <code>root</code> direktorijum za nov proces</li>
</ul>
</section>
<section id="objašnjenje-1" class="slide level2">
<h2>Objašnjenje</h2>
<ul>
<li>Sama ./tst komanda je trivijalni C program koji simulira ls komandu nad root direktorijumom</li>
<li>Služi da se demonstrira da smo za ovaj naš nov proces <code>root</code> nešto sasvim drugo</li>
</ul>
</section>
<section id="tst.c" class="slide level2">
<h2> tst.c </h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;dirent.h&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  DIR <span class="op">*</span>d<span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> dirent <span class="op">*</span>dd<span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>  d <span class="op">=</span> opendir<span class="op">(</span><span class="st">&quot;/&quot;</span><span class="op">);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>d<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">((</span>dd <span class="op">=</span> readdir<span class="op">(</span>d<span class="op">))</span> <span class="op">!=</span> NULL<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>      printf<span class="op">(</span><span class="st">&quot;%s</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> dd<span class="op">-&gt;</span>d_name<span class="op">);</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    closedir<span class="op">(</span>d<span class="op">);</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span><span class="cf">else</span><span class="op">{</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    fprintf<span class="op">(</span>stderr<span class="op">,</span> <span class="st">&quot;Ne mogu da otvorim korenski direktorijum.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
</section>
<section id="rezultat" class="slide level2">
<h2>Rezultat</h2>
<pre><code>.
..
chroot_works
tst.c
tst
usr
lib
lib64</code></pre>
</section>
<section id="rezultat-1" class="slide level2">
<h2>Rezultat</h2>
<ul>
<li>Izlistan, kao da je <code>root</code> je u stvari <code>tmp2</code> direktorijum</li>
<li>Jedino ograničenje je to što, da bi sistem radio, mora imati pristup <code>glibc</code></li>
<li>Stoga, radi jednostavnosti, direktorijumi sa bibliotekama su ulinkovani</li>
<li>U praksi, mi bi koristili posebne alate koji zahtevaju malo biblioteka ili su kompajlirani u statičkoj formi</li>
</ul>
</section>
<section id="šta-nam-ovo-govori" class="slide level2">
<h2>Šta nam ovo govori?</h2>
<ul>
<li>Verovali ili ne, ovo je dovoljno da se počne razvoj vaše verzije alata Docker</li>
<li>Naravno, Docker radi mnogo više stvari na mnogo kompleksniji način</li>
<li>Centralna ideja, sa druge strane, stvarno jeste ista</li>
<li>Umesto da se poziva komanda, poziva se sistemski poziv (isto ime), ali centralna ideja je identična</li>
</ul>
</section>
<section id="šta-je-još-potrebno" class="slide level2">
<h2>Šta je još potrebno?</h2>
<ul>
<li>Ako imamo sve ovo u običnoj korisnoj komandi, koji posao nam radi nešto kao što je Docker</li>
<li>Jako puno stvari, naravno, ali jedna od glavnih je nešto preko čega sam je preskočio u primeru</li>
<li>Linkovanje (Pomoću, ako vas zanima <code>mount -o bind</code> komande; bonus pitanje: zašto sam koristio <code>mount -o bind</code> umesto tvrdih linkova?) svih onih biblioteka nije trivijalan posao</li>
<li>Veliki izazov je pripremiti okruženje za kontejner</li>
</ul>
</section>
<section id="šta-je-još-potrebno-1" class="slide level2">
<h2>Šta je još potrebno?</h2>
<ul>
<li>Okruženje za VM je komplikovano, ali je to barem nešto vrlo slično instalaciji operativnog sistema</li>
<li>Znamo kako da radimo <em>to</em></li>
<li>Kako napraviti instalaciju nečega što malo jeste poseban OS, a malo nije?</li>
<li>Ovo se u svetu kontejnera tipično zove  image  odnosno slika i predstavlja neku vrstu ‘dehidriranog’ kontejnera</li>
<li>Više o ovome kasnije</li>
</ul>
</section></section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4//dist/reveal.js"></script>

  <!-- reveal.js plugins -->
  <script src="https://unpkg.com/reveal.js@^4//plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/zoom/zoom.js"></script>
  <script src="https://unpkg.com/reveal.js@^4//plugin/math/math.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: false,

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: false,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: false,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'slide',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'fade',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [
          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    </body>
</html>
